---
title: Building An Advanced Science-To-Blender Pipeline
layout: single
author_profile: true
read_time: true
share: true
date: '2019-06-16 14:30:00 -0800'
categories: coding
toc: true
---

I've been playing around with [blender][blender] again.

# Blender, again

I'd been thinking about submitting something for this year's [John D. Hunter Excellence in Plotting Contest`][jdh], but as it turned out I went away for about a week leading up to the final submission date, and didn't have anything prepared by the last day. I struggled for a few hours before the deadline to come up with something worth submitting, but nothing I tried seemed as visually impressive as I originally hoped it would be. Ultimately I just didn't have enough time to submit an entry, because I had made plans to travel with my parents on the final submission day, and I wasn't about to put off going on an awesome trip (Helsinki!) to make figures. But after returning from my trip, I wanted to complete my original goal: use Blender to make a visualization of something related to magnetism.

Back to Blender. Previously I made a [post][post] about how you can import scientific data into [Paraview][paraview], manipulate it, and export the result as a PLY file, which can then be imported into Blender for fancy visualization. That method is, for me, still the easiest way to produce great still images. There are however a few important shortcomings to consider before using this method:

1. Vertex colors just don't work with Eevee, the incredible new render engine introduced in Blender 2.8. This means you're restricted to using the Cycles engine, which is more accurate than Eevee but much, *much* slower.
2. Animations are almost impossible to make, in part because this method requires a lot of intermediate files (raw data -> VTK -> PLY -> Blender save) which take up a ton of disk space. Since you need a PLY file for each frame of an animation, the amount of storage you need for any sizeable dataset quickly grows beyond a reasonable size.
3. Because the PLY files generated by Paraview export *all* of the objects in view as a single mesh, they aren't really *separate* in any real sense in Blender. This means you can't do cool stuff like keyframing the properties of the objects you imported. They aren't really separate objects at all; the imported PLY is just a single object with a single mesh.[^1] For these reasons I needed to find another way to visualize my data. Fortunately, pretty much everything that you can do with the Blender GUI can also be done using the powerful python API, which makes reading in data really straightforward.

# How are magnetic materials simulated?

I really wanted to make an animation of how a ferromagnet reacts in response to a magnetic field; I've never seen any simulations showing the process (outside of academic papers and talks), and I think it has the potential to be visually appealing while still being understandable for non-scientists. On the microscopic scale, you can think of a magnetic material as being composed of many small bar magnets:

<figure class="align-center">
  <a href="https://simple.wikipedia.org/wiki/Magnet#/media/File:Bar_magnet.jpg">
    <img src="/assets/images/science_to_blender/magnet.svg" alt="">
  </a>
  <figcaption>
    <a href="https://simple.wikipedia.org/wiki/Magnet#/media/File:Bar_magnet.jpg" title="Source">
      Source
    </a>
  </figcaption>
</figure>

When a magnetic field is applied, these small magnets move and reorient themselves to align with the applied magnetic field. So the idea is to first simulate the motion of these microscopic magnetic moments and then visualize their motion in Blender. To produce the data I'll eventually be reading into Blender, I used the [Mumax3][Mumax] micromagnetics simulation package. In a nutshell, Mumax simulates the behavior of magnetic materials on the nanoscale by dividing up the simulated material into little cubic cells, each with its own magnetic moment. These little magnetic moments then are allowed to interact with each other according to the [Landau-Lifshitz-Gilbert][llg] equation, which describes how the little magnets move. The simulations shown here show how a thin, planar layer of perpendicularly magnetized material reacts when a magnetic field is applied out-of-plane.

To run a simulation, Mumax needs a configuration file which describes what kind of magnetic material you'd like it to simulate, what shape the materials is, and a number of other important parameters. As part of this configuration file, you can specify a number of options related to data output - what type of data you'd like, how often the magnetization is recorded, and so on. Usually, you would configure Mumax to write the magnetization of every simulation cell to a file every so often - say, every $10^{-12}$ seconds. The resulting files would contain the (x, y, z) locations and (mx, my, mz) spin vectors of the magnetization for each cell. Unfortunately this data isn't very useful to import into Blender because there's doesn't seem to be an easy way to take a Blender object - such as a cone - and align it along a certain vector[^2].

# Making a plan

To get around this limitation, I'll make use of Blender's `Axis Angle` rotation mode, which allows any object to be rotated around an arbitrary axis (given by a vector $\textbf{k}$) by a specified angle $\theta$. This transformation makes use of [Rodrigues' rotation formula][rodrigues],

$$
\textbf{v}_{rot} = \textbf{v}\cos Î¸ + (\textbf{k} \times \textbf{v})\sin \theta + \textbf{k}(\textbf{k}\cdot\textbf{v})(1-\cos \theta)
$$

which rotates the original vector $\textbf{v}$ into a new direction $\textbf{v}_{rot}$. Now the process of animating the simulated data in Blender becomes straightforward:

1. Create a cone at each cell location (x, y, z).
2. Set all of the rotation angles of the cones to 0. This orients the cones along the $+\hat{z}$-direction, i.e. $\textbf{v} = (0, 0, 1)$.
3. Read in the magnetization data $\textbf{v}_{rot}$ for the current timestep from the simulation.
4. For each cone, calculate $\theta$ and $\textbf{k}$ from the simulation data. Apply the `Axis Angle` transformation.
5. Keyframe the rotation of the cones.
6. Move to the next timestep and repeat from step 2.

Now the main problem is finding $\theta$ and $\textbf{k}$, but this isn't actually very hard. By default, the cones start out pointing up: $\textbf{v} = (0, 0, 1)$, and we want to use Blender to rotate $\textbf{v}$ to align with the magnetization data $$\textbf{v}_{rot}$$. This can always be done by choosing a rotation axis $\textbf{k}$ which lies in in the $xy$-plane. To find a direction of $\textbf{k}$ which works, just take the cross product $$\textbf{v} \times \textbf{v}_{rot}$$, which always points at right angles to both vectors. What about $\theta$? Well, since the cones start out pointing up, $\theta$ is just the same old polar angle you encounter whenever you use cylindrical coordinates! In summary:

$$
\begin{aligned}
\textbf{k} &= \textbf{v} \times \textbf{v}_{rot} \\
\theta &= \arccos (\textbf{v}_{rot} \cdot \hat{z})
\end{aligned}
$$

# Implementation

# Making it fancy

<video autoplay="autoplay" loop="loop" width="800" height="450" codecs="h264" controls>
  <source src="/assets/images/science_to_blender/dw_eyecandy.mp4" type="video/mp4">
</video>

[^1]: While you can actually split this single mesh into a bunch of separate objects in Blender, this still doesn't really solve the problem. For example, suppose I have some object in Paraview which moves as a function of time, and I want to make a movie of it in Blender. I can try to export my data in Paraview as a set of PLY files (`frame1.ply, frame2.ply, frame3.ply, ...`), like images from a flip-book. But there is still no way to tell Blender that the object I import from `frame1.ply` is the same object as in `frame2.ply`, shown at a different time. As far as Blender is concerned these are compeletely different objects, so Blender's most powerful animation features - specifically, keyframing the motion of objects - just won't work here.

[^2]: After posting this, I've discovered that you *can* in fact align objects to a vector using the mathutils.to_track_quat() function. Maybe I'll make another post about this later.

[magnet]: /assets/images/science_to_blender/magnet.svg
{: .align-center}

[blender]: www.blender.org
[jdh]: https://matplotlib.org/
[post]: {{ site.url }}{{ site.baseurl }}/coding/paraview-blender-workflow/
[paraview]: https://www.paraview.org/
[mumax]: https://mumax.github.io/
[llg]: https://en.wikipedia.org/wiki/Landau%E2%80%93Lifshitz%E2%80%93Gilbert_equation
[rodrigues]: https://en.wikipedia.org/wiki/Rodrigues'_rotation_formula